//
//  sensors.cpp
//

// public domain libs
#include <Arduino.h>
#include <OneWire.h>
#include <DallasTemperature.h>

// common includes
#include "config.h"
#include "smooth.h"

// task includes
#include "sensors.h"
#include "controller.h"
#include "comms.h"

// Temperature sensor
#define CFG_SMOOTH_SAMPLES (7) // must be odd number

// Loop delay
#define DELAY (2000)

// Queues
static xQueueHandle sensorsQueue = NULL;

// Sensors task-handle
static TaskHandle_t sensorsTaskHandle = NULL;

// ============================================================================
// SENSORS TASK
// ============================================================================

void sensorsTask(void *arg)
{
  static bool sensorDetected = false;
  static float tempSens = 0.0;
  static int tempSmooth = 0;
  static bool tempError = false;
  static int numSensors = 0;
  static bool tempValid = false;
  static controllerQItem_t qControllerMesg;

  static OneWire oneWire(CFG_TEMP_PIN);
  static DallasTemperature sensors(&oneWire);

  static Smooth<CFG_SMOOTH_SAMPLES> smooth;

  smooth.setMaxDeviation(10); // 1 degree

#if (CFG_TEMP_SENSOR_SIMULATION == false)
  // set-up DS18B20 temperature sensor(s)
  sensors.begin();
  sensors.setResolution(12);

  // TODO : support for multiple sensors
  numSensors = sensors.getDS18Count();
  printf("[SENSORS] Number of DS18B20 sensors found=%d\n", numSensors);
#else
  numSensors = 1;
#endif

  // inform controller about number of sensors discovered
  qControllerMesg.type = e_mtype_sensor;
  qControllerMesg.mesg.sensorMesg.mesgId = e_msg_sensor_numSensors;
  qControllerMesg.mesg.sensorMesg.data = numSensors;
  qControllerMesg.valid = true;
  controllerQueueSend(&qControllerMesg, 0);

  // TODO : support for NTC sensors

  while (true)
  {
    printf("[SENSORS] Set 0\n");
    digitalWrite(CFG_TEMP_PIN, 0);
    vTaskDelay(DELAY / portTICK_RATE_MS);

    printf("[SENSORS] Set 1\n");
    digitalWrite(CFG_TEMP_PIN, 1);
    vTaskDelay(DELAY / portTICK_RATE_MS);
  }

  while (true)
  {
    // printf("[SENSORS] LOOP..\n");

    if (sensorDetected == false)
    {
      printf("[SENSORS] Detecting Sensor\n");

      digitalWrite(CFG_TEMP_PIN, 0);
      vTaskDelay(2000 / portTICK_RATE_MS);
      digitalWrite(CFG_TEMP_PIN, 1);
      vTaskDelay(100 / portTICK_RATE_MS);
      oneWire.reset();
      vTaskDelay(100 / portTICK_RATE_MS);
      sensors.begin();
      vTaskDelay(100 / portTICK_RATE_MS);
    }

#if (CFG_TEMP_SENSOR_SIMULATION == false)
    if (numSensors > 0)
    {
      tempValid = false;
      sensors.requestTemperatures();

      // TODO : get temperatures for all discovered devices

#ifdef CFG_TEMP_IN_CELCIUS
      //      tempSens = sensors.getTempCByIndex(0);
      tempError = (tempSens == DEVICE_DISCONNECTED_C);
#elif CFG_TEMP_IN_FARENHEID
      temperature = sensors.getTempFByIndex(0);
      tempError = (tempSens == DEVICE_DISCONNECTED_F);
#else
      printf("[SENSORS] NO TEMPERATURE SENSOR DEFINED\n");
#endif

#else // CFG_TEMP_SENSOR_SIMULATION == true
    {
      tempSens = 5.0 + rand() * 30.0 / RAND_MAX;
      tempError = false;
      tempValid = false;
#endif
      if (tempError)
      {
        printf("[SENSORS] TEMPERATURE SENSOR ERROR !!!\n");

        // TODO : add optional power cycle

        // reset 1-wire bus
        vTaskDelay(500 / portTICK_RATE_MS);
        oneWire.reset();
        vTaskDelay(500 / portTICK_RATE_MS);
        vTaskDelay(500 / portTICK_RATE_MS);
        sensors.begin();
        vTaskDelay(500 / portTICK_RATE_MS);
      }
      else
      {
        // smooth measured temp * 100 (2 digits accuracy)
        smooth.setValue(tempSens * 10);

        if (smooth.isValid())
        {
          tempSmooth = smooth.getValue();
          tempValid = true;
        }
      }
    }

    // send temperature to controller-queue
    qControllerMesg.type = e_mtype_sensor;
    qControllerMesg.mesg.sensorMesg.mesgId = e_msg_sensor_temperature;
    qControllerMesg.mesg.sensorMesg.data = tempSmooth;
    qControllerMesg.valid = tempValid;
    controllerQueueSend(&qControllerMesg, 0);

    vTaskDelay(DELAY / portTICK_RATE_MS);
  }
};

// wrapper for sendQueue
int sensorsQueueSend(uint8_t *sensorsQMesg, TickType_t xTicksToWait)
{
  int r;
  r = pdTRUE;

  if (sensorsQueue != NULL)
  {
    r = xQueueSend(sensorsQueue, sensorsQMesg, xTicksToWait);
  }

  return r;
};

void initSensors(void)
{
  printf("[SENSORS] init\n");

  sensorsQueue = xQueueCreate(5, sizeof(uint8_t));

  if (sensorsQueue == 0)
  {
    printf("[SENSORS] Cannot create sensorsQueue. This is FATAL\n");
  }

  // create task
  xTaskCreate(sensorsTask, "sensorsTask", 4096, NULL, 10, &sensorsTaskHandle);
}

// end of file